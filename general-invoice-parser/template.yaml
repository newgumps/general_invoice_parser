AWSTemplateFormatVersion: '2010-09-09'
Transform: AWS::Serverless-2016-10-31
Description: >
  python3.8

  Sample SAM Template for General Invoice

# More info about Globals: https://github.com/awslabs/serverless-application-model/blob/master/docs/globals.rst
Parameters:
  NSSecrets:
    Type: String
    Default: winward-invoice-pdf-to-csv-upload-to-ns/key-secrets
  WorkDocsAccountCredentials:
    Type: AWS::SSM::Parameter::Value<String>
    Default: /workdocs/accounts/credentials
  NSFileCabinetIdPDFUploadFolder:
    Type: String
    Default: '838'
  NSFileCabinetIdCSVUploadFolder:
    Type: String
    Default: '634'
  NSSandboxProductionMode:
    Type: String
    Default: 'PRODUCTION'
  GumpsLoggingDDB:
    Type: String
    Default: GumpsStacksLog
  PreProcessingBucket:
    Type: String
    Default: preprocessing-bucket-to-be-parsed

  AttachmentsDDBStreams:
    Type: String
    Default: arn:aws:dynamodb:us-east-1:570685116845:table/Attachment-iumxb4tvivfkpokn5l7ot2wd64-staging/stream/2022-12-14T17:42:52.072

  PagesDDBStreams:
    Type: String
    Default: arn:aws:dynamodb:us-east-1:570685116845:table/Page-iumxb4tvivfkpokn5l7ot2wd64-staging/stream/2022-12-14T17:42:51.302

  APStateMachine:
    Type: String
    Default: arn:aws:states:us-east-1:570685116845:stateMachine:ap-automation
Resources:

  ReceivedEmailStorage:
    Type: 'AWS::S3::Bucket'

  AttachmentsStorage:
    Type: 'AWS::S3::Bucket'

  SavedInS3Notification:
    Type: 'AWS::SNS::Topic'

  SavedInS3NotificationPolicy:
    Type: 'AWS::SNS::TopicPolicy'
    Properties: 
      Topics: 
        - !Ref SavedInS3Notification
      PolicyDocument:
        { "Version": "2008-10-17",
              "Id": "__default_policy_ID",
              "Statement": [
                {
                  "Sid": "__default_statement_ID",
                  "Effect": "Allow",
                  "Principal": {
                    "Service": "ses.amazonaws.com"
                  },
                  "Action": "SNS:Publish",
                  "Resource": [{"Ref": SavedInS3Notification}],
                }
              ]
            }


  SavedInS3BucketPolicy:
    Type: AWS::S3::BucketPolicy
    Properties: 
      Bucket: !Ref "ReceivedEmailStorage"
      PolicyDocument:
        { "Version": "2008-10-17",
              "Id": "__default_policy_ID",
              "Statement": [
                {
                  "Sid": "__default_statement_ID",
                  "Effect": "Allow",
                  "Principal": {
                    "Service": "ses.amazonaws.com"
                  },
                  "Action": "s3:PutObject",
                  "Resource": {
                            "Fn::Join": [
                                "",
                                [
                                    "arn:aws:s3:::",
                                    {
                                        "Ref": "ReceivedEmailStorage"
                                    },
                                    "/*"
                                ]
                            ]
                        },
                }
              ]
            }



  ErrorNotificationSNS:
    Type: 'AWS::SNS::Topic'
    Properties: 
      DisplayName: 'Gumps Dropship PDF Error'
  
  SuccessNotificationSNS: # delete
    Type: 'AWS::SNS::Topic'
    Properties:
      DisplayName: 'Gumps Dropship PDF Success'


  PdfFileHandle: # delete
    Type: 'AWS::S3::Bucket'

  ProcessedCSVFileHandle: # delete
    Type: 'AWS::S3::Bucket'

  SNStoStepFunction: # vital 
    Type: AWS::Serverless::Function 
    Properties:
      Timeout: 20
      PackageType: Image
      Architectures:
        - "arm64"
      Policies: 

        - SNSCrudPolicy:
            TopicName: !GetAtt SavedInS3Notification.TopicName
        - StepFunctionsExecutionPolicy:
            StateMachineName: ap-automation

      Environment:
        Variables: 
          STATE_MACHINE_ARN: !Ref APStateMachine
    Metadata:
      Dockerfile: Dockerfile
      DockerContext: ./SNStoStepFunction
      DockerTag: python3.8-v1

  ExtractAttachmentsFromEmail: # vital
    Type: AWS::Serverless::Function 
    Properties:
      Timeout: 20
      PackageType: Image
      Architectures:
        - "arm64"
      Environment:
        Variables: 
          BUCKET : !Ref ReceivedEmailStorage
          SAVE_PDF_PREFIX: Received
          ERROR_NOTIFICATION_ARN: !Ref ErrorNotificationSNS
      Events:
        SNSEvent:
          Type: SNS
          Properties:
            Topic: !Ref SavedInS3Notification
      Policies: 

        - SNSCrudPolicy:
            TopicName: !GetAtt SavedInS3Notification.TopicName
        - S3CrudPolicy:
            BucketName: !Ref ReceivedEmailStorage
        - SNSCrudPolicy:
            TopicName: !GetAtt ErrorNotificationSNS.TopicName

      EventInvokeConfig:
        DestinationConfig:
          OnFailure:
            Type: SNS

    Metadata:
      Dockerfile: Dockerfile
      DockerContext: ./EmailToPdf
      DockerTag: python3.8-v1

  ErrorStorageBucket:
    Type: 'AWS::S3::Bucket'     
  
  CsvCompileFunction:
    Type: AWS::Serverless::Function
    
    Properties:
      Policies:
        - SNSPublishMessagePolicy:
            TopicName: !GetAtt SuccessNotificationSNS.TopicName
        - {
            "Version": "2012-10-17",
            "Statement": [
                {
                            "Sid": "VisualEditor0",
                            "Effect": "Allow",
                            "Action": [
                                "ssm:DescribeParameters",
                                "ssm:GetParametersByPath",
                                "ssm:GetParameters",
                                "ssm:GetParameter"
                            ],
                            "Resource": "*"
                        }
                    ]
            }
      Timeout: 30
      Environment:
        Variables:
          NSSecrets: !Ref NSSecrets
          SUCCESS_SNS_TOPIC: !Ref SuccessNotificationSNS
          UPLOAD_PDF_FOLDER_INTERNAL_ID: !Ref NSFileCabinetIdPDFUploadFolder
          UPLOAD_CSV_FOLDER_INTERNAL_ID: !Ref NSFileCabinetIdCSVUploadFolder
          NSSandboxProductionMode: !Ref NSSandboxProductionMode
      PackageType: Image
      Architectures:
        - arm64


    Metadata:
      Dockerfile: Dockerfile
      DockerContext: ./CsvCompiler
      DockerTag: python3.8-v1
  
  EmailParsingFunction:
    Type: AWS::Serverless::Function
    Properties:
      Policies: 
        - SNSCrudPolicy:
            TopicName: !GetAtt SavedInS3Notification.TopicName
        - S3CrudPolicy:
            BucketName: !Ref ReceivedEmailStorage
        - S3CrudPolicy:
            BucketName: !Ref AttachmentsStorage
        - DynamoDBCrudPolicy:
            TableName: "general-invoice-data"
        - {

          "Statement": [
            {
              "Effect": "Allow",
              "Action": [
                "cloudwatch:PutMetricData"
              ],
              "Resource": "*"
            }
          ]
          
            }     
        - {
            "Version": "2012-10-17",
            "Statement": [
                {
                            "Sid": "VisualEditor0",
                            "Effect": "Allow",
                            "Action": [
                                "ssm:DescribeParameters",
                                "ssm:GetParametersByPath",
                                "ssm:GetParameters",
                                "ssm:GetParameter"
                            ],
                            "Resource": "*"
                        }
                    ]
            }
      Timeout: 30
      Environment:
        Variables:
          ATTACHMENTS_BUCKET: !Ref AttachmentsStorage
      PackageType: Image
      Architectures:
        - arm64
      Events:
        SNSEvent:
          Type: SNS
          Properties:
            Topic: !Ref SavedInS3Notification
    Metadata:
      Dockerfile: Dockerfile
      DockerContext: ./extract_pdf_attachments
      DockerTag: python3.8-v1
  
  PDFPagesStorage:
    Type: 'AWS::S3::Bucket'
    
  CheckFoldersInWorkDocs:
    Type: AWS::Serverless::Function
    Properties:
        Handler: index.handler
        CodeUri: inline
        Runtime: python3.8
        Layers:
          - arn:aws:lambda:us-east-1:770693421928:layer:Klayers-p38-requests:10
        Environment:
          Variables:
            WORKDOCS_ACCOUNT_CREDENTIALS: !Ref WorkDocsAccountCredentials
        InlineCode: |
          import requests
          import boto3
          import os
          import json
          # Get Credentials
          WORKDOCS_ACCOUNT_CREDENTIALS = json.loads(os.environ['WORKDOCS_ACCOUNT_CREDENTIALS'])

          SECRET_KEY = WORKDOCS_ACCOUNT_CREDENTIALS.get('SECRET_KEY')
          ACCESS_KEY = WORKDOCS_ACCOUNT_CREDENTIALS.get('ACCESS_KEY')
          accessToken = WORKDOCS_ACCOUNT_CREDENTIALS.get('accessToken')
          endpoint = WORKDOCS_ACCOUNT_CREDENTIALS.get('endpoint')

          def query_graphql_ap_inbox_db(accessToken, endpoint, query):
              # establish a session with requests session
              session = requests.Session()
              # As found in AWS Appsync under Settings for your endpoint.
              APPSYNC_API_ENDPOINT_URL = endpoint
              # Now we can simply post the request...
              response = session.request(
                  url=APPSYNC_API_ENDPOINT_URL,
                  method='POST',
                  headers={'x-api-key': accessToken},
                  json={'query': query}
              )
              return response.json()
              
          def handler(event, context):
              # Check for match with vendor names domains
              email_domain = event['extract_pdf_attachments']['OriginalSender']
              graphql_query = f"""
                  query MyQuery {{
                  listVendors(limit: 1000, filter: {{known_email_domain: {{contains: "{email_domain}"}}}}) {{
              
              
                      items {{
                      id
                      workdocs_folder_id
                      workdocs_folder_name
                      manual_process
                      exclude
                      alt_names
                      }}
                  }}
                  }}
                  """
              response = query_graphql_ap_inbox_db(accessToken, endpoint, graphql_query)
              if response['data']['listVendors']['items'] != []:
                  return {
                      "vendors_db_id": (response['data']['listVendors']['items'][0]['id'] or None),
                      "workdocs_folder_name": (response['data']['listVendors']['items'][0]['workdocs_folder_name'] or None),
                      "workdocs_folder_id": (response['data']['listVendors']['items'][0]['workdocs_folder_id'] or None),
                      "manual_process": (response['data']['listVendors']['items'][0]['manual_process'] or None),
                      "exclude": (response['data']['listVendors']['items'][0]['exclude'] or None),
                      "alt_names": (response['data']['listVendors']['items'][0]['alt_names'] or None),
              
                  }
              else:
                  pass
              # Else try to match on vendor names
              vendors_names = event['PageCompile']['PageCompile']['Vendor Names']
              if vendors_names == None:
                  vendors_names = "No Vendor"
              def convert_to_dynamodb_friendly(string):
                  """Converts any string to a DynamoDB-friendly string"""
                  return string.replace('\\', '\\\\').replace('\n', '\\n').replace('\r', '\\r').replace('\t', '\\t').replace('\'', '\\\'').replace('\"', '\\"')
              
              
              vendors_name_modifify = [convert_to_dynamodb_friendly(vendor) for vendor in vendors_names]
              
              for vendor_names in vendors_name_modifify:
                  graphql_query = f"""
                      query MyQuery {{
                      listVendors(limit: 1000, filter: {{alt_names: {{contains: "{vendor_names}"}}}}) {{
              
              
                          items {{
                          id
                          workdocs_folder_id
                          workdocs_folder_name
                          manual_process
                          exclude
                          alt_names
                          }}
                      }}
                      }}
              
              
              
              
                      """ 

                  response = query_graphql_ap_inbox_db(accessToken, endpoint, graphql_query)
                  print(response)
                  if "errors" in response:
                      graphql_query = f"""
                          query MyQuery {{
                          listVendors(limit: 1000, filter: {{alt_names: {{contains: "{vendors_names}"}}}}) {{
                  
                      
                              items {{
                              id
                              workdocs_folder_id
                              workdocs_folder_name
                              manual_process
                              exclude
                              alt_names
                              }}
                          }}
                          }}
                      
                      
                      
                      
                          """ 
                      response = query_graphql_ap_inbox_db(accessToken, endpoint, graphql_query)
                      print(response)
                  #if response['data']['listVendors']['items'] != []:
                  #    break
                  #else:
                  #    continue
              try:
                  return {
                      "vendors_db_id": (response['data']['listVendors']['items'][0]['id'] or None),
                      "workdocs_folder_name": (response['data']['listVendors']['items'][0]['workdocs_folder_name'] or None),
                      "workdocs_folder_id": (response['data']['listVendors']['items'][0]['workdocs_folder_id'] or None),
                      "manual_process": (response['data']['listVendors']['items'][0]['manual_process'] or None),
                      "exclude": (response['data']['listVendors']['items'][0]['exclude'] or None),
                      "alt_names": (response['data']['listVendors']['items'][0]['alt_names'] or None),
              
                  }
              except:
                  return {
                      "vendors_db_id": None,
                      "workdocs_folder_name": "Unmatched Vendors",
                      "workdocs_folder_id": 'b206124fa331f849b1cfc608875092c2664a3300dd0a36acf211ce7388074ca1',
                      "manual_process": None,
                      "exclude": None,
                      "alt_names": None,
              
                  }

  AddToWorkDocsErrorsFolders:
    Type: AWS::Serverless::Function
    Properties:
      Handler: index.handler
      CodeUri: inline
      Runtime: python3.9
      Timeout: 30
      Environment:
        Variables:
          WORKDOCS_ACCOUNT_CREDENTIALS: !Ref WorkDocsAccountCredentials
      Layers:
        - arn:aws:lambda:us-east-1:770693421928:layer:Klayers-p38-requests:10
      InlineCode: |
        import boto3
        import requests
        import json
        # Get Credentials
        WORKDOCS_ACCOUNT_CREDENTIALS = json.loads(os.environ['WORKDOCS_ACCOUNT_CREDENTIALS'])

        SECRET_KEY = WORKDOCS_ACCOUNT_CREDENTIALS.get('SECRET_KEY')
        ACCESS_KEY = WORKDOCS_ACCOUNT_CREDENTIALS.get('ACCESS_KEY')
        parent_folder_id = WORKDOCS_ACCOUNT_CREDENTIALS.get('parent_folder_id')
        accessToken = WORKDOCS_ACCOUNT_CREDENTIALS.get('accessToken')
        endpoint = WORKDOCS_ACCOUNT_CREDENTIALS.get('endpoint')


        def handler(event, context):
            session = boto3.Session()
            session_workdoc_acc = boto3.Session(
                aws_access_key_id=ACCESS_KEY,
                aws_secret_access_key=SECRET_KEY
            )
            
            workdocs_client = session_workdoc_acc.client('workdocs')
            s3_resource = session.resource('s3')
            BUCKET_NAME = event['extract_pdf_attachments']['attachments']['BUCKET_NAME']
            KEY = event['extract_pdf_attachments']['attachments']['KEY']
            s3_obj = s3_resource.Object(BUCKET_NAME, KEY)
            s3_obj_response_body=s3_obj.get()['Body'].read()
            s3_obj_response=s3_obj.get()
            obj_type= 'application/pdf'
            
            workdocs_response = workdocs_client.initiate_document_version_upload(
                Name=KEY,
                ContentType=obj_type,
                ParentFolderId=parent_folder_id
            )
            
            URL=workdocs_response['UploadMetadata']['UploadUrl']
            workdocs_upload = requests.put(URL,headers = workdocs_response['UploadMetadata']['SignedHeaders'],data=s3_obj_response_body) 

            update_response = workdocs_client.update_document_version(
                DocumentId=workdocs_response['Metadata']['Id'],
                VersionId=workdocs_response['Metadata']['LatestVersionMetadata']['Id'],
                VersionStatus='ACTIVE'
            )     
            cloudwatch_client = boto3.client('cloudwatch')

            cloudwatch_client.put_metric_data(
                Namespace='Gumps AP Inbox',
                MetricData = [
                    {
                        'MetricName': 'Error folder',
                        'Unit': "None",
                        'Value': 1
                    }],
                
                )
            return {
                'statusCode': KEY,
                'body': update_response
            }

  
  TextractResultsFunction:
    Type: AWS::Serverless::Function
    Properties:
      Handler: index.handler
      CodeUri: inline
      Runtime: python3.9
      Policies:
        - SNSCrudPolicy:
            TopicName: !Ref APWaitForTextractTopic
        - SQSPollerPolicy:
            QueueName: !Ref APWaitTextractsQueue
        - StepFunctionsExecutionPolicy:
            StateMachineName: ap-automation
      Environment:
        Variables:
          SQS_URL: !Ref APWaitTextractsQueue
      Events:
        APWaitTextractsQueue:
          Type: SNS
          Properties:
            Topic: !Ref APWaitForTextractTopic
      InlineCode: |
        import json
        import boto3
        import os 
        queue_url = os.environ['SQS_URL']
        sqs = boto3.client('sqs')
        textract_client = boto3.client('textract')
        sfn = boto3.client('stepfunctions')

        def handler(event, context):
            print(event)
            extraction = json.loads(event['Records'][0]['Sns']['Message'])
            JOBID = extraction['JobId']
            STATUS = extraction['Status']
            
            SUCCESS_TOKEN = None
            while SUCCESS_TOKEN is None:
                response = sqs.receive_message(
                    QueueUrl=queue_url,
                    AttributeNames=['All'],
                    MaxNumberOfMessages=10,
                    WaitTimeSeconds=20
                )
                
                for message in response['Messages']:
                    print(message)
                    receipt_handle = message['ReceiptHandle']
                    message_dict = json.loads(message['Body'])
                    if message_dict['JobID'] == JOBID:
                        SUCCESS_TOKEN = message_dict['MyTaskToken']
                        response = sfn.send_task_success(
                            taskToken=SUCCESS_TOKEN,
                            output=json.dumps({'textract_output': JOBID})
                            )
                        print("Send Task Success Response:", response)
                        sqs.delete_message(
                            QueueUrl=queue_url,
                            ReceiptHandle=message['ReceiptHandle']
                                )
                            
            if SUCCESS_TOKEN is None:
                raise Exception("No matching JobID found in SQS queue")

            return {"Status": "Success"}


  SplitPagesTextractFunction:
    Type: AWS::Serverless::Function
    Properties:
      Handler: index.handler
      CodeUri: inline
      Runtime: python3.9
      Timeout: 30
      Policies:
        - TextractPolicy: {}
      Environment:
        Variables:
          WORKDOCS_ACCOUNT_CREDENTIALS: !Ref WorkDocsAccountCredentials
      Layers:
        - arn:aws:lambda:us-east-1:770693421928:layer:Klayers-p38-requests:10
      InlineCode: |
        import boto3
        import requests
        import json
        import os
        def query_graphql_ap_inbox_db(accessToken, endpoint, query):
            # establish a session with requests session
            session = requests.Session()
            # As found in AWS Appsync under Settings for your endpoint.
            APPSYNC_API_ENDPOINT_URL = endpoint
            # Now we can simply post the request...
            response = session.request(
                url=APPSYNC_API_ENDPOINT_URL,
                method='POST',
                headers={'x-api-key': accessToken},
                json={'query': query}
            )
            return response.json()
        # Get Credentials
        WORKDOCS_ACCOUNT_CREDENTIALS = json.loads(os.environ['WORKDOCS_ACCOUNT_CREDENTIALS'])

        SECRET_KEY = WORKDOCS_ACCOUNT_CREDENTIALS.get('SECRET_KEY')
        ACCESS_KEY = WORKDOCS_ACCOUNT_CREDENTIALS.get('ACCESS_KEY')
        parent_folder_id = WORKDOCS_ACCOUNT_CREDENTIALS.get('parent_folder_id')
        accessToken = WORKDOCS_ACCOUNT_CREDENTIALS.get('accessToken')
        endpoint = WORKDOCS_ACCOUNT_CREDENTIALS.get('endpoint')
    
        def handler(event, context):
            JOBID = event['TextractResults']['textract_output']
            textract_client = boto3.client('textract')
            
            response = textract_client.get_expense_analysis(
                MaxResults= 20,
                JobId= JOBID)
            
            NUMOFPAGES = response['DocumentMetadata']['Pages']
            
            LISTOFPAGES = [pages['SummaryFields'] for pages in response['ExpenseDocuments']]
            
            ATTACHMENT_ID = event['extract_pdf_attachments']['attachments']['AttachmentId']
            
            LISTOFPAGESID = []
            for num, pages in enumerate(LISTOFPAGES):
                graphql_query = f"""
                    mutation MyMutation {{
                createPage(input: {{attachmentID: "{ATTACHMENT_ID}", textract_result: {json.dumps(json.dumps(pages))}, page_num: {str(num+1)}}}) {{
                    id
                }}
                }}
            
                    """
                response = query_graphql_ap_inbox_db(accessToken, endpoint, graphql_query)
                print(response)
                LISTOFPAGESID.append(response['data']['createPage'])
            

            return {
                'List of Pages': LISTOFPAGESID
            }



  PullAlertsQueue:

    Type: AWS::Serverless::Function
    Properties:
      Handler: index.handler
      CodeUri: inline
      Runtime: python3.9
      Environment:
        Variables:
          SQS_QUEUE_URL: !Ref APAlertsQueue
      Policies:
        - SQSPollerPolicy:
            QueueName:
              !GetAtt APAlertsQueue.QueueName
      InlineCode: |
        def handler(event, context):
            return {
                'statusCode': 200,
                'body': 'Hello from the zip archive'
            }

  ProcessTextract:
    # Note: SNS Arn and Roles may need update. ie.Notification Channel
    Type: AWS::Serverless::Function
    Properties:
      Policies: 
        - S3CrudPolicy:
            BucketName: !Ref AttachmentsStorage
        - TextractPolicy: {}
        - CloudWatchPutMetricPolicy: {}
        - SNSCrudPolicy:
            TopicName: !GetAtt  APWaitForTextractTopic.TopicName
      Environment:
        Variables:
          SNS_TOPIC_ARN: !Ref APWaitForTextractTopic
      Handler: index.handler
      CodeUri: inline
      Runtime: python3.9
      InlineCode: |
        import boto3

        def handler(event, context):
            cloudwatch_client = boto3.client('cloudwatch')

            cloudwatch_client.put_metric_data(
                Namespace='Gumps AP Inbox',
                MetricData = [
                    {
                        'MetricName': 'Send to Texract',
                        'Dimensions': [
              
                            ],
                        'Unit': "None",
                        'Value': 1
                    }],
                
                )

            textract_client = boto3.client('textract')

            response = textract_client.start_expense_analysis(
                DocumentLocation={
                    'S3Object': {
                        'Bucket': event['extract_pdf_attachments']['attachments']['BUCKET_NAME'],
                        'Name': event['extract_pdf_attachments']['attachments']['KEY']
                    }
                },
                NotificationChannel={
                    "SNSTopicArn": "arn:aws:sns:us-east-1:570685116845:APWaitForTextractTopic",
                    "RoleArn": "arn:aws:iam::570685116845:role/textract-sns-publish"
                }
            )

            return {
                "job_Id": response['JobId']
            }

  APAlertsQueue:
    Type: AWS::SQS::Queue
    Properties:
      QueueName: 
        !Join
        - '-'
        - - !Ref AWS::StackName
          - 'APAlertsQueue'


  APWaitTextractsQueue:
    Type: AWS::SQS::Queue
    Properties:
      QueueName: 
        !Join
        - '-'
        - - !Ref AWS::StackName
          - APWaitTextractsQueue

  APWaitForTextractTopic:
    Type: AWS::SNS::Topic
    Properties:
      TopicName: 
        !Join
        - '-'
        - - !Ref AWS::StackName
          - APWaitForTextractTopic


  APAlertsTopic:
    Type: AWS::SNS::Topic
    Properties:
      TopicName: 
        !Join
        - '-'
        - - !Ref AWS::StackName
          - APAlertsTopic


  AddToWorkDocsNonPDFFolders:
    # make sure parent folders id correspond to the correct folder in workdocs
    Type: AWS::Serverless::Function
    Properties:
      Handler: index.handler
      CodeUri: inline
      Runtime: python3.9
      Timeout: 30
      Policies:
        - TextractPolicy: {}
        - S3CrudPolicy:
            BucketName: !Ref AttachmentsStorage
        - CloudWatchPutMetricPolicy: {}
      Environment:
        Variables:
          WORKDOCS_ACCOUNT_CREDENTIALS: !Ref WorkDocsAccountCredentials
      Layers:
        - arn:aws:lambda:us-east-1:770693421928:layer:Klayers-p38-requests:10
      InlineCode: |
        import mimetypes
        import boto3
        import json
        import requests
        import os
        # Get Credentials
        WORKDOCS_ACCOUNT_CREDENTIALS = json.loads(os.environ['WORKDOCS_ACCOUNT_CREDENTIALS'])

        SECRET_KEY = WORKDOCS_ACCOUNT_CREDENTIALS.get('SECRET_KEY')
        ACCESS_KEY = WORKDOCS_ACCOUNT_CREDENTIALS.get('ACCESS_KEY')
        parent_folder_id = WORKDOCS_ACCOUNT_CREDENTIALS.get('parent_folder_id')
        accessToken = WORKDOCS_ACCOUNT_CREDENTIALS.get('accessToken')
        endpoint = WORKDOCS_ACCOUNT_CREDENTIALS.get('endpoint')
        parent_folder_id = '87afa1936584edd9019217fd4c1242ac79caf8919158ebdf1dd1a73885f2881b'

        def handler(event, context):
            session = boto3.Session()
            session_workdoc_acc = boto3.Session(
                aws_access_key_id=ACCESS_KEY,
                aws_secret_access_key=SECRET_KEY
            )
            
            workdocs_client = session_workdoc_acc.client('workdocs')
            s3_resource = session.resource('s3')
            BUCKET_NAME = event['extract_pdf_attachments']['attachments']['BUCKET_NAME']
            KEY = event['extract_pdf_attachments']['attachments']['KEY']
            print(KEY)
                
            mime_type, encoding = mimetypes.guess_type(KEY)
            if KEY.split('.')[-1] == 'xlsx':
                mime_type = 'application/vnd.openxmlformats-officedocument.spreadsheetml.sheet'
            print(mime_type)
            if mime_type == None:
                mime_type = 'application/octet-stream'
            if mime_type in ['image/jpeg', 'image/png']:
                cloudwatch_client = boto3.client('cloudwatch')

                cloudwatch_client.put_metric_data(
                    Namespace='Gumps AP Inbox',
                    MetricData = [
                        {
                            'MetricName': 'Non Pdf (img)',
                            'Unit': "None",
                            'Value': 1
                        }],
                    
                    )
                return {
                    'statusCode': 'Unsaved Mimetype',
                    'body': KEY + " is not saved in workdocs."}
            cloudwatch_client = boto3.client('cloudwatch')

            cloudwatch_client.put_metric_data(
                Namespace='Gumps AP Inbox',
                MetricData = [
                    {
                        'MetricName': 'Pdf Save',
                        'Unit': "None",
                        'Value': 1
                    }],
                
                )
            s3_obj = s3_resource.Object(BUCKET_NAME, KEY)
            s3_obj_response_body=s3_obj.get()['Body'].read()
            s3_obj_response=s3_obj.get()
            workdocs_response = workdocs_client.initiate_document_version_upload(
                Name=KEY,
                ContentType=mime_type,
                ParentFolderId=parent_folder_id
            )
            
            URL=workdocs_response['UploadMetadata']['UploadUrl']
            workdocs_upload = requests.put(URL,headers = workdocs_response['UploadMetadata']['SignedHeaders'],data=s3_obj_response_body) 

            update_response = workdocs_client.update_document_version(
                DocumentId=workdocs_response['Metadata']['Id'],
                VersionId=workdocs_response['Metadata']['LatestVersionMetadata']['Id'],
                VersionStatus='ACTIVE'
            )     
            cloudwatch_client = boto3.client('cloudwatch')

            cloudwatch_client.put_metric_data(
                Namespace='Gumps AP Inbox',
                MetricData = [
                    {
                        'MetricName': 'Non Pdf Saved',
                        'Unit': "None",
                        'Value': 1
                    }],
                
                )
            return {
                'statusCode': KEY,
                'body': update_response
            }


  FileRenamingFunction:
    Type: AWS::Serverless::Function
    Properties:
      Handler: index.handler
      CodeUri: inline
      Runtime: python3.9
      Policies: 
        - CloudWatchPutMetricPolicy: {}
      Timeout: 9
      InlineCode: |
        import datetime
        from dateutil.parser import parse
        import boto3
        def handler(event, context):
            list_of_invoices = []
            for page_list in event['PageCompile']['PageCompile']['Groups of Commons']:
                print(page_list)
                INVOICE_RECEIPT_ID = None
                PO_NUMBER = None
                INVOICE_RECEIPT_ID = None
                INVOICE_DATE = None
                PAGE_LIST = page_list
                for page in page_list:
                    
                    try:
                        INVOICE_RECEIPT_ID = event['PagesProcess'][int(page)-1]["ExtractInvoiceFromPages"]["ExtractInvoiceFromPages"]["Extracted"]["INVOICE_RECEIPT_ID"][0]["Text"]
                        print(INVOICE_RECEIPT_ID)
                        cloudwatch_client = boto3.client('cloudwatch')
            
                        cloudwatch_client.put_metric_data(
                            Namespace='Gumps AP Inbox',
                            MetricData = [
                                {
                                    'MetricName': 'Invoice Id Found',
                                    'Unit': "None",
                                    'Value': 1
                                }],
                            
                            )
                    except:
                        INVOICE_RECEIPT_ID = None
                    try:
                        PO_NUMBER = event['PagesProcess'][int(page)-1]["ExtractInvoiceFromPages"]["ExtractInvoiceFromPages"]["Extracted"]["PO_NUMBER"][0]["Text"] 
                    except:
                        PO_NUMBER = None
                    try:
                        INVOICE_DATE = event['PagesProcess'][int(page)-1]["ExtractInvoiceFromPages"]["ExtractInvoiceFromPages"]["Extracted"]["INVOICE_RECEIPT_DATE"][0]["Text"]
                    except:
                        INVOICE_DATE = None
                    try:
                        parsed_date = parse(INVOICE_DATE)
                    except:
                        parsed_date = datetime.date.today()
                    INVOICE_DATE = parsed_date.strftime('%Y%m%d')
                    print("INVOICE_RECEIPT_ID", INVOICE_RECEIPT_ID)
        
                    

                    if INVOICE_RECEIPT_ID == None and PO_NUMBER == None:
                        INVOICE_RECEIPT_ID = event['PagesProcess'][int(page)-1]["ExtractInvoiceFromPages"]["ExtractInvoiceFromPages"]["Extracted"]["PAGE_ID"]
                        PO_NUMBER = None
                    
                    elif INVOICE_RECEIPT_ID == None:
                        INVOICE_RECEIPT_ID =  event['PagesProcess'][int(page)-1]["ExtractInvoiceFromPages"]["ExtractInvoiceFromPages"]["Extracted"]["PAGE_ID"]
                    elif PO_NUMBER == None:
                        PO_NUMBER =  event['PagesProcess'][int(page)-1]["ExtractInvoiceFromPages"]["ExtractInvoiceFromPages"]["Extracted"]["PAGE_ID"]
                        
                    PAGE_ID = event['PagesProcess'][int(page)-1]["ExtractInvoiceFromPages"]["ExtractInvoiceFromPages"]["Extracted"]["PAGE_ID"]
                
                    list_of_invoices.append({"INVOICE_RECEIPT_ID": INVOICE_RECEIPT_ID, "PO_NUMBER": PO_NUMBER, "INVOICE_DATE": INVOICE_DATE, "PAGE_LIST": PAGE_LIST, "PAGE_ID": PAGE_ID})
                    
                    
            
            
            
            return {
                're_name_file_name': list_of_invoices
            }


  PageCompile:
    Type: AWS::Serverless::Function
    Properties:
      Handler: index.handler
      CodeUri: inline
      Runtime: python3.9
      Timeout: 9

      InlineCode: |
        import boto3
        def handler(event, context):
            unprocessed_pages = {}
            grouped_data = {}
            
            for processed_page in event['PagesProcess']:
                cloudwatch_client = boto3.client('cloudwatch')

                cloudwatch_client.put_metric_data(
                    Namespace='Gumps AP Inbox',
                    MetricData = [
                        {
                            'MetricName': 'Page Found',
                            'Unit': "None",
                            'Value': 1
                        }],
                    
                    )
                PAGENUMSTR = str(processed_page['ExtractInvoiceFromPages']['ExtractInvoiceFromPages']['Extracted']['PAGE_NUM'])
                try:
                    invoice_receipt_id = processed_page['ExtractInvoiceFromPages']['ExtractInvoiceFromPages']['Extracted']['INVOICE_RECEIPT_ID'][0]['Text']
                except:
                    invoice_receipt_id = 'Not Found'
                    
                unprocessed_pages[PAGENUMSTR] = invoice_receipt_id
                
                if invoice_receipt_id in grouped_data:
                    grouped_data[invoice_receipt_id].append(PAGENUMSTR)
                else:
                    grouped_data[invoice_receipt_id] = [PAGENUMSTR]
            
            # Convert the dictionary to a list of lists
            result = [grouped_data[value] for value in grouped_data]
            
            for num, group in enumerate(result):
                # check if group is a no vendor id.
                if unprocessed_pages[group[0]] == 'Not Found':
                    if num == 0:
                        try:
                            result[num+1].extend(group)
                            del result[num]
                        except:
                            pass
                    else:
                        result[num-1].extend(group)
                        del result[num]
            for inner_list in result:
                inner_list.sort()
            pages_process = event['PagesProcess']
            vendor_names = []
            for page in pages_process:
                extracted_data = page["ExtractInvoiceFromPages"]["ExtractInvoiceFromPages"]["Extracted"]
                vendor_name_list = extracted_data["VENDOR_NAME"]
                
                for vendor in vendor_name_list:
                    vendor_name = vendor["Text"]
                    
                    if vendor_name not in vendor_names:
                        vendor_names.append(vendor_name)
            
            print(vendor_names)
            return {
                "Groups of Commons":result,
                "Vendor Names":vendor_names
                
            }

  TextractExtractFunction:
    Type: AWS::Serverless::Function
    Properties:
      Handler: index.handler
      CodeUri: inline
      Runtime: python3.9
      Timeout: 9
      Policies:
          - TextractPolicy: {}
          - S3CrudPolicy:
              BucketName: !Ref AttachmentsStorage
          - CloudWatchPutMetricPolicy: {}
      Environment:
        Variables:
          WORKDOCS_ACCOUNT_CREDENTIALS: !Ref WorkDocsAccountCredentials
      InlineCode: |
        import requests
        import boto3
        import os
        import json
        # Get Credentials
        WORKDOCS_ACCOUNT_CREDENTIALS = json.loads(os.environ['WORKDOCS_ACCOUNT_CREDENTIALS'])

        SECRET_KEY = WORKDOCS_ACCOUNT_CREDENTIALS.get('SECRET_KEY')
        ACCESS_KEY = WORKDOCS_ACCOUNT_CREDENTIALS.get('ACCESS_KEY')
        parent_folder_id = WORKDOCS_ACCOUNT_CREDENTIALS.get('parent_folder_id')
        accessToken = WORKDOCS_ACCOUNT_CREDENTIALS.get('accessToken')
        endpoint = WORKDOCS_ACCOUNT_CREDENTIALS.get('endpoint')
        parent_folder_id = '87afa1936584edd9019217fd4c1242ac79caf8919158ebdf1dd1a73885f2881b'
 
        def query_graphql_ap_inbox_db(accessToken, endpoint, query):
            # establish a session with requests session
            session = requests.Session()
            # As found in AWS Appsync under Settings for your endpoint.
            APPSYNC_API_ENDPOINT_URL = endpoint
            # Now we can simply post the request...
            response = session.request(
                url=APPSYNC_API_ENDPOINT_URL,
                method='POST',
                headers={'x-api-key': accessToken},
                json={'query': query}
            )
            return response.json()
        def handler(event, context):
            print(event)
            PAGE_ID = event['id']
            
            graphql_query = f"""
                query MyQuery {{
                getPage(id: "{PAGE_ID}") {{
                    textract_result
                    page_num
                    attachmentID
                }}
                }}
            
            
                """
            response = query_graphql_ap_inbox_db(accessToken, endpoint, graphql_query)
            
            TEXTRACTOUTPUTS = eval(response['data']['getPage']['textract_result'])
            PAGE_NUM = response['data']['getPage']['page_num']
            ATTACHMENTS_ID = response['data']['getPage']['attachmentID']

            list_of_fields = [
                'INVOICE_RECEIPT_ID',
                'INVOICE_RECEIPT_DATE',
                'PO_NUMBER',
                'VENDOR_NAME'
            ]
            
            
            key_fields_value = {}
            for field in list_of_fields:
                key_fields_value[field] = []
            for fields in TEXTRACTOUTPUTS:
                if fields['Type']['Text'] in list_of_fields:
                        key_fields_value[fields['Type']['Text']].append({
                            'Text': fields['ValueDetection']['Text'],
                            'Confidence': fields['Type']['Confidence']
                        }  
                        )
            
            key_fields_value['PAGE_NUM'] = PAGE_NUM
            key_fields_value['ATTACHMENTS_ID'] = ATTACHMENTS_ID
            key_fields_value['PAGE_ID'] = PAGE_ID
            return {
                    "Extracted": key_fields_value
                }

      Layers:
        - arn:aws:lambda:us-east-1:770693421928:layer:Klayers-p38-requests:10

  AddToWorkDocs:
    Type: AWS::Serverless::Function
    Properties:
      Handler: index.handler
      CodeUri: inline
      Runtime: python3.8
      Timeout: 12
      Policies:
          - TextractPolicy: {}
          - S3CrudPolicy:
              BucketName: !Ref AttachmentsStorage
          - CloudWatchPutMetricPolicy: {}
      Environment:
        Variables:
          WORKDOCS_ACCOUNT_CREDENTIALS: !Ref WorkDocsAccountCredentials
      InlineCode: |
        import requests
        import boto3
        import json
        import os
        # Get Credentials
        WORKDOCS_ACCOUNT_CREDENTIALS = json.loads(os.environ['WORKDOCS_ACCOUNT_CREDENTIALS'])

        SECRET_KEY = WORKDOCS_ACCOUNT_CREDENTIALS.get('SECRET_KEY')
        ACCESS_KEY = WORKDOCS_ACCOUNT_CREDENTIALS.get('ACCESS_KEY')
        accessToken = WORKDOCS_ACCOUNT_CREDENTIALS.get('accessToken')
        endpoint = WORKDOCS_ACCOUNT_CREDENTIALS.get('endpoint')
        parent_folder_id = '87afa1936584edd9019217fd4c1242ac79caf8919158ebdf1dd1a73885f2881b'
 
        def handler(event, context):
            session = boto3.Session()
            session_workdoc_acc = boto3.Session(
                aws_access_key_id=ACCESS_KEY,
                aws_secret_access_key=SECRET_KEY
            )
            
            workdocs_client = session_workdoc_acc.client('workdocs')
            s3_resource = session.resource('s3')
            KEY = event['KEY']
            BUCKET_NAME = event['BUCKET_NAME']
            rename_files = event['KEY']
            s3_obj = s3_resource.Object(BUCKET_NAME, KEY)
            s3_obj_response_body=s3_obj.get()['Body'].read()
            s3_obj_response=s3_obj.get()
            folder_id = event['workdocs_folder_id']
            if folder_id == 'b206124fa331f849b1cfc608875092c2664a3300dd0a36acf211ce7388074ca1':
                cloudwatch_client = boto3.client('cloudwatch')

                cloudwatch_client.put_metric_data(
                    Namespace='Gumps AP Inbox',
                    MetricData = [
                        {
                            'MetricName': 'Unmatched Vendors',
                            'Unit': "None",
                            'Value': 1
                        }],
                    
                    )
            else:
                cloudwatch_client = boto3.client('cloudwatch')

                cloudwatch_client.put_metric_data(
                    Namespace='Gumps AP Inbox',
                    MetricData = [
                        {
                            'MetricName': 'Matched Vendors',
                            'Unit': "None",
                            'Value': 1
                        }],
                    
                    )
            obj_type= 'application/pdf'

                
            workdocs_response = workdocs_client.initiate_document_version_upload(
                Name=rename_files,
                ContentType=obj_type,
                ParentFolderId=folder_id
            )
            
            URL=workdocs_response['UploadMetadata']['UploadUrl']
            workdocs_upload = requests.put(URL,headers = workdocs_response['UploadMetadata']['SignedHeaders'],data=s3_obj_response_body) 

            update_response = workdocs_client.update_document_version(
                DocumentId=workdocs_response['Metadata']['Id'],
                VersionId=workdocs_response['Metadata']['LatestVersionMetadata']['Id'],
                VersionStatus='ACTIVE'
            )

            return {
                's3_key': KEY,
                'uploaded_file_name' : rename_files,
                'body': update_response
            }

      Layers:
        - arn:aws:lambda:us-east-1:770693421928:layer:Klayers-p38-requests:10

  GenerateUploadList:
    Type: AWS::Serverless::Function
    Properties:
      Timeout: 60
      Handler: index.handler
      CodeUri: inline
      Runtime: python3.8
      InlineCode: |
        def handler(event, context):
            workdocs_folder_id = event['FolderStatus']['FolderStatus']['workdocs_folder_id']
            receipts = event['SplitPdfInvoice']['SplitPdfInvoice']['body']
            list_of_processed_receipts = event['SplitPdfInvoice']['SplitPdfInvoice']['body']
            uuid = event['extract_pdf_attachments']['UUID']
            for idx, receipt in enumerate(receipts):
                list_of_processed_receipts[idx]['workdocs_folder_id'] = workdocs_folder_id
                if receipt['INVOICE_RECEIPT_ID'] == receipt['PAGE_ID'] or receipt['PO_NUMBER'] == receipt['PAGE_ID']:
                    list_of_processed_receipts[idx]['NS_PASS'] = False
                else:
                    list_of_processed_receipts[idx]['NS_PASS'] = True
            
            list_of_processed_receipts
            return list_of_processed_receipts
  
  SplitPDFbyGroups:
    Type: AWS::Serverless::Function
    Properties:
      Timeout: 60
      PackageType: Image
      Architectures:
        - arm64
    Metadata:
      Dockerfile: Dockerfile
      DockerContext: ./split_pdf_by_groups
      DockerTag: python3.8-v1
        
  ExtractInvoiceFromPagesFunction:
    Type: AWS::Serverless::Function
    Properties:
      Policies: 
        - SQSSendMessagePolicy:
            QueueName: !GetAtt  CSVCompilerQueue.QueueName
        - S3CrudPolicy:
            BucketName: !Ref PDFPagesStorage
        - S3CrudPolicy:
            BucketName: !Ref AttachmentsStorage
      Events:
        Stream:
          Type: DynamoDB
          Properties:
            Stream: !Ref PagesDDBStreams
            BatchSize: 1
            StartingPosition: LATEST
      Timeout: 30
      PackageType: Image
      Architectures:
        - arm64
      Environment:
        Variables:
          SQS_QUEUE_URL: !Ref CSVCompilerQueue
    Metadata:
      Dockerfile: Dockerfile
      DockerContext: ./extract_invoice_from_pages
      DockerTag: python3.8-v1

  CSVCompilerQueue:
    Type: AWS::SQS::Queue

  CSVsStorage:
    Type: 'AWS::S3::Bucket'
  CSVCompilerFunction:
    Type: AWS::Serverless::Function
    Properties:
      Timeout: 30
      Policies:
        - S3CrudPolicy:
            BucketName: !Ref CSVsStorage
        - SQSPollerPolicy:
            QueueName: !GetAtt CSVCompilerQueue.QueueName
        - {
            "Version": "2012-10-17",
            "Statement": [
                {
                            "Sid": "VisualEditor0",
                            "Effect": "Allow",
                            "Action": [
                                "ssm:DescribeParameters",
                                "ssm:GetParametersByPath",
                                "ssm:GetParameters",
                                "ssm:GetParameter"
                            ],
                            "Resource": "*"
                        }
                    ]
            }
      PackageType: Image
      Architectures:
        - arm64
      Events:
        SQSEvent:
          Type: SQS
          Properties:
            Queue: !GetAtt CSVCompilerQueue.Arn
            BatchSize: 100
            MaximumBatchingWindowInSeconds: 20
    Metadata:
      Dockerfile: Dockerfile
      DockerContext: ./csv_compile
      DockerTag: python3.8-v1
