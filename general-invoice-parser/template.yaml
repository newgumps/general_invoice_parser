AWSTemplateFormatVersion: '2010-09-09'
Transform: AWS::Serverless-2016-10-31
Description: >
  python3.8

  Sample SAM Template for General Invoice

# More info about Globals: https://github.com/awslabs/serverless-application-model/blob/master/docs/globals.rst
Parameters:
  EmailPrefix:
    Type: String
    Default: "Received"
  PDFPrefix:
    Type: String
    Default: "PDF"
  NSSecrets:
    Type: String
    Default: winward-invoice-pdf-to-csv-upload-to-ns/key-secrets
  WorkDocsAccountCredentials:
    Type: AWS::SSM::Parameter::Value<String>
    Default: /workdocs/accounts/credentials
  NSFileCabinetIdPDFUploadFolder:
    Type: String
    Default: '838'
  NSFileCabinetIdCSVUploadFolder:
    Type: String
    Default: '634'
  NSSandboxProductionMode:
    Type: String
    Default: 'PRODUCTION'
  GumpsLoggingDDB:
    Type: String
    Default: GumpsStacksLog
  PreProcessingBucket:
    Type: String
    Default: preprocessing-bucket-to-be-parsed

  AttachmentsDDBStreams:
    Type: String
    Default: arn:aws:dynamodb:us-east-1:570685116845:table/Attachment-iumxb4tvivfkpokn5l7ot2wd64-staging/stream/2022-12-14T17:42:52.072

  PagesDDBStreams:
    Type: String
    Default: arn:aws:dynamodb:us-east-1:570685116845:table/Page-iumxb4tvivfkpokn5l7ot2wd64-staging/stream/2022-12-14T17:42:51.302

  APStateMachine:
    Type: String
    Default: arn:aws:states:us-east-1:570685116845:stateMachine:ap-automation
Resources:

  ReceivedEmailStorage:
    Type: 'AWS::S3::Bucket'

  AttachmentsStorage:
    Type: 'AWS::S3::Bucket'

  SavedInS3Notification:
    Type: 'AWS::SNS::Topic'

  SavedInS3NotificationPolicy:
    Type: 'AWS::SNS::TopicPolicy'
    Properties: 
      Topics: 
        - !Ref SavedInS3Notification
      PolicyDocument:
        { "Version": "2008-10-17",
              "Id": "__default_policy_ID",
              "Statement": [
                {
                  "Sid": "__default_statement_ID",
                  "Effect": "Allow",
                  "Principal": {
                    "Service": "ses.amazonaws.com"
                  },
                  "Action": "SNS:Publish",
                  "Resource": [{"Ref": SavedInS3Notification}],
                }
              ]
            }


  SavedInS3BucketPolicy:
    Type: AWS::S3::BucketPolicy
    Properties: 
      Bucket: !Ref "ReceivedEmailStorage"
      PolicyDocument:
        { "Version": "2008-10-17",
              "Id": "__default_policy_ID",
              "Statement": [
                {
                  "Sid": "__default_statement_ID",
                  "Effect": "Allow",
                  "Principal": {
                    "Service": "ses.amazonaws.com"
                  },
                  "Action": "s3:PutObject",
                  "Resource": {
                            "Fn::Join": [
                                "",
                                [
                                    "arn:aws:s3:::",
                                    {
                                        "Ref": "ReceivedEmailStorage"
                                    },
                                    "/*"
                                ]
                            ]
                        },
                }
              ]
            }



  ErrorNotificationSNS:
    Type: 'AWS::SNS::Topic'
    Properties: 
      DisplayName: 'Gumps Dropship PDF Error'
  
  SuccessNotificationSNS: # delete
    Type: 'AWS::SNS::Topic'
    Properties:
      DisplayName: 'Gumps Dropship PDF Success'


  PdfFileHandle: # delete
    Type: 'AWS::S3::Bucket'

  ProcessedCSVFileHandle: # delete
    Type: 'AWS::S3::Bucket'

  SNStoStepFunction: # vital 
    Type: AWS::Serverless::Function 
    Properties:
      Timeout: 20
      PackageType: Image
      Architectures:
        - "arm64"
      Policies: 

        - SNSCrudPolicy:
            TopicName: !GetAtt SavedInS3Notification.TopicName
        - StepFunctionsExecutionPolicy:
            StateMachineName: ap-automation

      Environment:
        Variables: 
          STATE_MACHINE_ARN: !Ref APStateMachine
    Metadata:
      Dockerfile: Dockerfile
      DockerContext: ./SNStoStepFunction
      DockerTag: python3.8-v1

  ExtractAttachmentsFromEmail: # vital
    Type: AWS::Serverless::Function 
    Properties:
      Timeout: 20
      PackageType: Image
      Architectures:
        - "arm64"
      Environment:
        Variables: 
          BUCKET : !Ref ReceivedEmailStorage
          SAVE_PDF_PREFIX: !Ref PDFPrefix
          ERROR_NOTIFICATION_ARN: !Ref ErrorNotificationSNS
      Events:
        SNSEvent:
          Type: SNS
          Properties:
            Topic: !Ref SavedInS3Notification
      Policies: 

        - SNSCrudPolicy:
            TopicName: !GetAtt SavedInS3Notification.TopicName
        - S3CrudPolicy:
            BucketName: !Ref ReceivedEmailStorage
        - SNSCrudPolicy:
            TopicName: !GetAtt ErrorNotificationSNS.TopicName

      EventInvokeConfig:
        DestinationConfig:
          OnFailure:
            Type: SNS

    Metadata:
      Dockerfile: Dockerfile
      DockerContext: ./EmailToPdf
      DockerTag: python3.8-v1

  ErrorStorageBucket:
    Type: 'AWS::S3::Bucket'
  ParsePDFFunction:
    Type: AWS::Serverless::Function # More info about Function Resource: https://github.com/awslabs/serverless-application-model/blob/master/versions/2016-10-31.md#awsserverlessfunction
    Properties:
      Timeout: 80
      PackageType: Image
      Architectures:
        - "arm64"

      Policies:
        - {
        
            "Statement": [
            {
                "Effect": "Allow",
                "Action": [
                  "textract:*"
                ],
                "Resource": "*"
              }
            ]
          }
        - DynamoDBCrudPolicy:
            TableName: "general-invoice-data"
        - DynamoDBWritePolicy:
            TableName: !Ref GumpsLoggingDDB
        - S3CrudPolicy:
            BucketName: !Ref ReceivedEmailStorage
        - S3CrudPolicy:
            BucketName: !Ref ErrorStorageBucket
        - S3CrudPolicy:
            BucketName: !Ref PreProcessingBucket
        - S3CrudPolicy:
            BucketName: !Ref PdfFileHandle
        - S3CrudPolicy:
            BucketName: !Ref ProcessedCSVFileHandle

        - SNSPublishMessagePolicy:
            TopicName: !GetAtt ErrorNotificationSNS.TopicName
        - {
            "Version": "2012-10-17",
            "Statement": [
                {
                            "Sid": "VisualEditor0",
                            "Effect": "Allow",
                            "Action": [
                                "ssm:DescribeParameters",
                                "ssm:GetParametersByPath",
                                "ssm:GetParameters",
                                "ssm:GetParameter"
                            ],
                            "Resource": "*"
                        }
                    ]
            }

      Environment:
        Variables:
          PDF_FILE_HANDLE_BUCKET: !Ref PdfFileHandle
          PROCESSED_CSV_FILE_HANDLE_BUCKET: !Ref ProcessedCSVFileHandle
          NSSecrets: !Ref NSSecrets
          BUCKET_NAME_ERRORS: !Ref ErrorStorageBucket
          ERROR_NOTIFICATION_ARN: !Ref ErrorNotificationSNS
          UPLOAD_PDF_FOLDER_INTERNAL_ID: !Ref NSFileCabinetIdPDFUploadFolder
          UPLOAD_CSV_FOLDER_INTERNAL_ID: !Ref NSFileCabinetIdCSVUploadFolder
          NSSandboxProductionMode: !Ref NSSandboxProductionMode
    Metadata:
      Dockerfile: Dockerfile
      DockerContext: ./PdfParser
      DockerTag: python3.8-v1      
  
  CsvCompileFunction:
    Type: AWS::Serverless::Function
    
    Properties:
      Policies:
        - SNSPublishMessagePolicy:
            TopicName: !GetAtt SuccessNotificationSNS.TopicName
        - {
            "Version": "2012-10-17",
            "Statement": [
                {
                            "Sid": "VisualEditor0",
                            "Effect": "Allow",
                            "Action": [
                                "ssm:DescribeParameters",
                                "ssm:GetParametersByPath",
                                "ssm:GetParameters",
                                "ssm:GetParameter"
                            ],
                            "Resource": "*"
                        }
                    ]
            }
      Timeout: 30
      Environment:
        Variables:
          NSSecrets: !Ref NSSecrets
          SUCCESS_SNS_TOPIC: !Ref SuccessNotificationSNS
          UPLOAD_PDF_FOLDER_INTERNAL_ID: !Ref NSFileCabinetIdPDFUploadFolder
          UPLOAD_CSV_FOLDER_INTERNAL_ID: !Ref NSFileCabinetIdCSVUploadFolder
          NSSandboxProductionMode: !Ref NSSandboxProductionMode
      PackageType: Image
      Architectures:
        - arm64


    Metadata:
      Dockerfile: Dockerfile
      DockerContext: ./CsvCompiler
      DockerTag: python3.8-v1
  
  EmailParsingFunction:
    Type: AWS::Serverless::Function
    Properties:
      Policies: 
        - SNSCrudPolicy:
            TopicName: !GetAtt SavedInS3Notification.TopicName
        - S3CrudPolicy:
            BucketName: !Ref ReceivedEmailStorage
        - S3CrudPolicy:
            BucketName: !Ref AttachmentsStorage
        - DynamoDBCrudPolicy:
            TableName: "general-invoice-data"
        - {

          "Statement": [
            {
              "Effect": "Allow",
              "Action": [
                "cloudwatch:PutMetricData"
              ],
              "Resource": "*"
            }
          ]
          
            }     
        - {
            "Version": "2012-10-17",
            "Statement": [
                {
                            "Sid": "VisualEditor0",
                            "Effect": "Allow",
                            "Action": [
                                "ssm:DescribeParameters",
                                "ssm:GetParametersByPath",
                                "ssm:GetParameters",
                                "ssm:GetParameter"
                            ],
                            "Resource": "*"
                        }
                    ]
            }
      Timeout: 30
      Environment:
        Variables:
          ATTACHMENTS_BUCKET: !Ref AttachmentsStorage
      PackageType: Image
      Architectures:
        - arm64
      Events:
        SNSEvent:
          Type: SNS
          Properties:
            Topic: !Ref SavedInS3Notification
    Metadata:
      Dockerfile: Dockerfile
      DockerContext: ./extract_pdf_attachments
      DockerTag: python3.8-v1
  
  PDFPagesStorage:
    Type: 'AWS::S3::Bucket'
    
  SplitPdfFunction:
    Type: AWS::Serverless::Function
    Properties:
      Environment:
        Variables:
          TOPIC_ARN: !Ref SavePdfPagesTopic
          PDF_PAGES_BUCKET: !Ref PDFPagesStorage
      Policies: 
        - AWSLambdaDynamoDBExecutionRole
        - SNSCrudPolicy:
            TopicName: !GetAtt  SavePdfPagesTopic.TopicName
        - S3CrudPolicy:
            BucketName: !Ref AttachmentsStorage
        - S3CrudPolicy:
            BucketName: !Ref PDFPagesStorage
        - LambdaInvokePolicy:
            FunctionName: !Ref ProcessWithTextractFunction
      Timeout: 30
      Events:
        Stream:
          Type: DynamoDB
          Properties:
            Stream: !Ref AttachmentsDDBStreams
            BatchSize: 1
            StartingPosition: LATEST
            FilterCriteria:
              Filters:
                - Pattern: '{ "dynamodb": { "NewImage": { "type": { "S": ["application/pdf"] } } } }'
      PackageType: Image
      Architectures:
        - arm64
    Metadata:
      Dockerfile: Dockerfile
      DockerContext: ./split_pdf
      DockerTag: python3.8-v1

  SavePdfPagesTopic:
    Type: AWS::SNS::Topic
  ProcessWithTextractFunction:
    Type: AWS::Serverless::Function
    Properties:
      Timeout: 15
      Events:
        SNSEvent:
          Type: SNS
          Properties:
            Topic: !Ref SavePdfPagesTopic
      Environment:
        Variables:
          TOPIC_ARN: !Ref SavePdfPagesTopic
      Policies: 
        - S3CrudPolicy:
            BucketName: !Ref AttachmentsStorage
        - TextractPolicy: {}
        - CloudWatchPutMetricPolicy: {}
        - S3CrudPolicy:
            BucketName: !Ref PDFPagesStorage
        - SNSCrudPolicy:
            TopicName: !GetAtt  SavePdfPagesTopic.TopicName
      PackageType: Image
      Architectures:
        - arm64
    Metadata:
      Dockerfile: Dockerfile
      DockerContext: ./process_with_textract
      DockerTag: python3.8-v1

  CheckFoldersInWorkDocs:
    Type: AWS::Serverless::Function
    Properties:
        Handler: index.handler
        CodeUri: inline
        Runtime: python3.8
        Layers:
          - arn:aws:lambda:us-east-1:770693421928:layer:Klayers-p38-requests:10
        Environment:
          Variables:
            WORKDOCS_ACCOUNT_CREDENTIALS: !Ref WorkDocsAccountCredentials
        InlineCode: |
          import requests
          import boto3
          import os

          # Get Credentials
          WORKDOCS_ACCOUNT_CREDENTIALS = json.loads(os.environ['WORKDOCS_ACCOUNT_CREDENTIALS'])

          SECRET_KEY = WORKDOCS_ACCOUNT_CREDENTIALS.get('SECRET_KEY')
          ACCESS_KEY = WORKDOCS_ACCOUNT_CREDENTIALS.get('ACCESS_KEY')
          parent_folder_id = WORKDOCS_ACCOUNT_CREDENTIALS.get('parent_folder_id')
          accessToken = WORKDOCS_ACCOUNT_CREDENTIALS.get('accessToken')
          endpoint = WORKDOCS_ACCOUNT_CREDENTIALS.get('endpoint')

          def query_graphql_ap_inbox_db(accessToken, endpoint, query):
              # establish a session with requests session
              session = requests.Session()
              # As found in AWS Appsync under Settings for your endpoint.
              APPSYNC_API_ENDPOINT_URL = endpoint
              # Now we can simply post the request...
              response = session.request(
                  url=APPSYNC_API_ENDPOINT_URL,
                  method='POST',
                  headers={'x-api-key': accessToken},
                  json={'query': query}
              )
              return response.json()
              
          def handler(event, context):
              # Check for match with vendor names domains
              email_domain = event['extract_pdf_attachments']['OriginalSender']
              graphql_query = f"""
                  query MyQuery {{
                  listVendors(limit: 1000, filter: {{known_email_domain: {{contains: "{email_domain}"}}}}) {{
              
              
                      items {{
                      id
                      workdocs_folder_id
                      workdocs_folder_name
                      manual_process
                      exclude
                      alt_names
                      }}
                  }}
                  }}
                  """
              response = query_graphql_ap_inbox_db(accessToken, endpoint, graphql_query)
              if response['data']['listVendors']['items'] != []:
                  return {
                      "vendors_db_id": (response['data']['listVendors']['items'][0]['id'] or None),
                      "workdocs_folder_name": (response['data']['listVendors']['items'][0]['workdocs_folder_name'] or None),
                      "workdocs_folder_id": (response['data']['listVendors']['items'][0]['workdocs_folder_id'] or None),
                      "manual_process": (response['data']['listVendors']['items'][0]['manual_process'] or None),
                      "exclude": (response['data']['listVendors']['items'][0]['exclude'] or None),
                      "alt_names": (response['data']['listVendors']['items'][0]['alt_names'] or None),
              
                  }
              else:
                  pass
              # Else try to match on vendor names
              vendors_names = event['PageCompile']['PageCompile']['Vendor Names']
              if vendors_names == None:
                  vendors_names = "No Vendor"
              def convert_to_dynamodb_friendly(string):
                  """Converts any string to a DynamoDB-friendly string"""
                  return string.replace('\\', '\\\\').replace('\n', '\\n').replace('\r', '\\r').replace('\t', '\\t').replace('\'', '\\\'').replace('\"', '\\"')
              
              
              vendors_name_modifify = [convert_to_dynamodb_friendly(vendor) for vendor in vendors_names]
              
              for vendor_names in vendors_name_modifify:
                  graphql_query = f"""
                      query MyQuery {{
                      listVendors(limit: 1000, filter: {{alt_names: {{contains: "{vendor_names}"}}}}) {{
              
              
                          items {{
                          id
                          workdocs_folder_id
                          workdocs_folder_name
                          manual_process
                          exclude
                          alt_names
                          }}
                      }}
                      }}
              
              
              
              
                      """ 

                  response = query_graphql_ap_inbox_db(accessToken, endpoint, graphql_query)
                  print(response)
                  if "errors" in response:
                      graphql_query = f"""
                          query MyQuery {{
                          listVendors(limit: 1000, filter: {{alt_names: {{contains: "{vendors_names}"}}}}) {{
                  
                      
                              items {{
                              id
                              workdocs_folder_id
                              workdocs_folder_name
                              manual_process
                              exclude
                              alt_names
                              }}
                          }}
                          }}
                      
                      
                      
                      
                          """ 
                      response = query_graphql_ap_inbox_db(accessToken, endpoint, graphql_query)
                      print(response)
                  #if response['data']['listVendors']['items'] != []:
                  #    break
                  #else:
                  #    continue
              try:
                  return {
                      "vendors_db_id": (response['data']['listVendors']['items'][0]['id'] or None),
                      "workdocs_folder_name": (response['data']['listVendors']['items'][0]['workdocs_folder_name'] or None),
                      "workdocs_folder_id": (response['data']['listVendors']['items'][0]['workdocs_folder_id'] or None),
                      "manual_process": (response['data']['listVendors']['items'][0]['manual_process'] or None),
                      "exclude": (response['data']['listVendors']['items'][0]['exclude'] or None),
                      "alt_names": (response['data']['listVendors']['items'][0]['alt_names'] or None),
              
                  }
              except:
                  return {
                      "vendors_db_id": None,
                      "workdocs_folder_name": "Unmatched Vendors",
                      "workdocs_folder_id": 'b206124fa331f849b1cfc608875092c2664a3300dd0a36acf211ce7388074ca1',
                      "manual_process": None,
                      "exclude": None,
                      "alt_names": None,
              
                  }

  AddToWorkDocsErrorsFolders:
    Type: AWS::Serverless::Function
    Properties:
      Handler: index.handler
      CodeUri: inline
      Runtime: python3.9
      Environment:
        Variables:
          WORKDOCS_ACCOUNT_CREDENTIALS: !Ref WorkDocsAccountCredentials
      Layers:
        - arn:aws:lambda:us-east-1:770693421928:layer:Klayers-p38-requests:10
      InlineCode: |
        import boto3
        import requests
        # Get Credentials
        WORKDOCS_ACCOUNT_CREDENTIALS = json.loads(os.environ['WORKDOCS_ACCOUNT_CREDENTIALS'])

        SECRET_KEY = WORKDOCS_ACCOUNT_CREDENTIALS.get('SECRET_KEY')
        ACCESS_KEY = WORKDOCS_ACCOUNT_CREDENTIALS.get('ACCESS_KEY')
        parent_folder_id = WORKDOCS_ACCOUNT_CREDENTIALS.get('parent_folder_id')
        accessToken = WORKDOCS_ACCOUNT_CREDENTIALS.get('accessToken')
        endpoint = WORKDOCS_ACCOUNT_CREDENTIALS.get('endpoint')


        def handler(event, context):
            session = boto3.Session()
            session_workdoc_acc = boto3.Session(
                aws_access_key_id=ACCESS_KEY,
                aws_secret_access_key=SECRET_KEY
            )
            
            workdocs_client = session_workdoc_acc.client('workdocs')
            s3_resource = session.resource('s3')
            BUCKET_NAME = event['extract_pdf_attachments']['attachments']['BUCKET_NAME']
            KEY = event['extract_pdf_attachments']['attachments']['KEY']
            s3_obj = s3_resource.Object(BUCKET_NAME, KEY)
            s3_obj_response_body=s3_obj.get()['Body'].read()
            s3_obj_response=s3_obj.get()
            obj_type= 'application/pdf'
            
            workdocs_response = workdocs_client.initiate_document_version_upload(
                Name=KEY,
                ContentType=obj_type,
                ParentFolderId=parent_folder_id
            )
            
            URL=workdocs_response['UploadMetadata']['UploadUrl']
            workdocs_upload = requests.put(URL,headers = workdocs_response['UploadMetadata']['SignedHeaders'],data=s3_obj_response_body) 

            update_response = workdocs_client.update_document_version(
                DocumentId=workdocs_response['Metadata']['Id'],
                VersionId=workdocs_response['Metadata']['LatestVersionMetadata']['Id'],
                VersionStatus='ACTIVE'
            )     
            cloudwatch_client = boto3.client('cloudwatch')

            cloudwatch_client.put_metric_data(
                Namespace='Gumps AP Inbox',
                MetricData = [
                    {
                        'MetricName': 'Error folder',
                        'Unit': "None",
                        'Value': 1
                    }],
                
                )
            return {
                'statusCode': KEY,
                'body': update_response
            }

  
  TextractResultsFunction:
    Type: AWS::Serverless::Function
    Properties:
      Handler: index.handler
      CodeUri: inline
      Runtime: python3.9
      Policies:
        - SNSCrudPolicy:
            TopicName: !Ref APWaitForTextractTopic
        - SQSPollerPolicy:
            QueueName: !Ref APWaitTextractsQueue
        - StepFunctionsExecutionPolicy:
            StateMachineName: ap-automation
      Environment:
        Variables:
          SQS_URL: !Ref APWaitTextractsQueue
      Events:
        APWaitTextractsQueue:
          Type: SNS
          Properties:
            Topic: !Ref APWaitForTextractTopic
      InlineCode: |
        import json
        import boto3
        import os 
        queue_url = os.environ['SQS_URL']
        sqs = boto3.client('sqs')
        textract_client = boto3.client('textract')
        sfn = boto3.client('stepfunctions')

        def handler(event, context):
            print(event)
            extraction = json.loads(event['Records'][0]['Sns']['Message'])
            JOBID = extraction['JobId']
            STATUS = extraction['Status']
            
            SUCCESS_TOKEN = None
            while SUCCESS_TOKEN is None:
                response = sqs.receive_message(
                    QueueUrl=queue_url,
                    AttributeNames=['All'],
                    MaxNumberOfMessages=10,
                    WaitTimeSeconds=20
                )
                
                for message in response['Messages']:
                    print(message)
                    receipt_handle = message['ReceiptHandle']
                    message_dict = json.loads(message['Body'])
                    if message_dict['JobID'] == JOBID:
                        SUCCESS_TOKEN = message_dict['MyTaskToken']
                        response = sfn.send_task_success(
                            taskToken=SUCCESS_TOKEN,
                            output=json.dumps({'textract_output': JOBID})
                            )
                        print("Send Task Success Response:", response)
                        sqs.delete_message(
                            QueueUrl=queue_url,
                            ReceiptHandle=message['ReceiptHandle']
                                )
                            
            if SUCCESS_TOKEN is None:
                raise Exception("No matching JobID found in SQS queue")

            return {"Status": "Success"}


  QueryJobIDFunction:
    Type: AWS::Serverless::Function
    Properties:
      Handler: index.handler
      CodeUri: inline
      Runtime: python3.9
      InlineCode: |
        def handler(event, context):
            return {
                'statusCode': 200,
                'body': 'Hello from the zip archive'
            }
  SplitPagesTextractFunction:
    Type: AWS::Serverless::Function
    Properties:
      Handler: index.handler
      CodeUri: inline
      Runtime: python3.9
      InlineCode: |
        def handler(event, context):
            return {
                'statusCode': 200,
                'body': 'Hello from the zip archive'
            }


  ReturnTextractOutcomesFunction:
    Type: AWS::Serverless::Function
    Properties:
      Handler: index.handler
      CodeUri: inline
      Runtime: python3.9
      InlineCode: |
        def handler(event, context):
            return {
                'statusCode': 200,
                'body': 'Hello from the zip archive'
            }

  PullAlertsQueue:

    Type: AWS::Serverless::Function
    Properties:
      Handler: index.handler
      CodeUri: inline
      Runtime: python3.9
      Environment:
        Variables:
          SQS_QUEUE_URL: !Ref APAlertsQueue
      Policies:
        - SQSPollerPolicy:
            QueueName:
              !GetAtt APAlertsQueue.QueueName
      InlineCode: |
        def handler(event, context):
            return {
                'statusCode': 200,
                'body': 'Hello from the zip archive'
            }

  ProcessTextract:
    # Note: SNS Arn and Roles may need update. ie.Notification Channel
    Type: AWS::Serverless::Function
    Properties:
      Policies: 
        - S3CrudPolicy:
            BucketName: !Ref AttachmentsStorage
        - TextractPolicy: {}
        - CloudWatchPutMetricPolicy: {}
        - SNSCrudPolicy:
            TopicName: !GetAtt  APWaitForTextractTopic.TopicName
      Environment:
        Variables:
          SNS_TOPIC_ARN: !Ref APWaitForTextractTopic
      Handler: index.handler
      CodeUri: inline
      Runtime: python3.9
      InlineCode: |
        import boto3

        def handler(event, context):
            cloudwatch_client = boto3.client('cloudwatch')

            cloudwatch_client.put_metric_data(
                Namespace='Gumps AP Inbox',
                MetricData = [
                    {
                        'MetricName': 'Send to Texract',
                        'Dimensions': [
              
                            ],
                        'Unit': "None",
                        'Value': 1
                    }],
                
                )

            textract_client = boto3.client('textract')

            response = textract_client.start_expense_analysis(
                DocumentLocation={
                    'S3Object': {
                        'Bucket': event['extract_pdf_attachments']['attachments']['BUCKET_NAME'],
                        'Name': event['extract_pdf_attachments']['attachments']['KEY']
                    }
                },
                NotificationChannel={
                    "SNSTopicArn": "arn:aws:sns:us-east-1:570685116845:APWaitForTextractTopic",
                    "RoleArn": "arn:aws:iam::570685116845:role/textract-sns-publish"
                }
            )

            return {
                "job_Id": response['JobId']
            }




  APAlertsQueue:
    Type: AWS::SQS::Queue
    Properties:
      QueueName: APAlertsQueue

  APWaitTextractsQueue:
    Type: AWS::SQS::Queue
    Properties:
      QueueName: APWaitTextractsQueue

  APWaitForTextractTopic:
    Type: AWS::SNS::Topic
    Properties:
      TopicName: APWaitForTextractTopic


  APAlertsTopic:
    Type: AWS::SNS::Topic
    Properties:
      TopicName: APAlertsTopic

  GenerateAlertsDocs:
    Type: AWS::Serverless::Function
    Properties:
      Handler: index.handler
      CodeUri: inline
      Runtime: python3.9
      InlineCode: |
        def handler(event, context):
            return {
                'statusCode': 200,
                'body': 'Hello from the zip archive'
            }

  UploadAlertsDocsToWorkDocs:
    Type: AWS::Serverless::Function
    Properties:
      Handler: index.handler
      CodeUri: inline
      Runtime: python3.9
      InlineCode: |
        def handler(event, context):
            return {
                'statusCode': 200,
                'body': 'Hello from the zip archive'
            }

  AddToWorkDocsMissingVendorsFolders:
    Type: AWS::Serverless::Function
    Properties:
      Handler: index.handler
      CodeUri: inline
      Runtime: python3.9
      InlineCode: |
        def handler(event, context):
            return {
                'statusCode': 200,
                'body': 'Hello from the zip archive'
            }

  AddToWorkDocsNonPDFFolders:
    Type: AWS::Serverless::Function
    Properties:
      Handler: index.handler
      CodeUri: inline
      Runtime: python3.9
      InlineCode: |
        def handler(event, context):
            return {
                'statusCode': 200,
                'body': 'Hello from the zip archive'
            }

  FileRenamingFunction:
    Type: AWS::Serverless::Function
    Properties:
      Handler: index.handler
      CodeUri: inline
      Runtime: python3.9
      InlineCode: |
        def handler(event, context):
            return {
                'statusCode': 200,
                'body': 'Hello from the zip archive'
            }

  PageCompile:
    Type: AWS::Serverless::Function
    Properties:
      Handler: index.handler
      CodeUri: inline
      Runtime: python3.9
      InlineCode: |
        def handler(event, context):
            return {
                'statusCode': 200,
                'body': 'Hello from the zip archive'
            }

  AddToWorkDocsNoVendorsFolders:
    Type: AWS::Serverless::Function
    Properties:
      Handler: index.handler
      CodeUri: inline
      Runtime: python3.9
      Timeout: 9
      InlineCode: |
        def handler(event, context):
            return {
                'statusCode': 200,
                'body': 'Hello from the zip archive'
                }
      Layers:
        - arn:aws:lambda:us-east-1:770693421928:layer:Klayers-p38-requests:10
    
  TextractExtractFunction:
    Type: AWS::Serverless::Function
    Properties:
      Handler: index.handler
      CodeUri: inline
      Runtime: python3.9
      Timeout: 9
      InlineCode: |
        def handler(event, context):
            return {
                'statusCode': 200,
                'body': 'Hello from the zip archive'
                }
      Layers:
        - arn:aws:lambda:us-east-1:770693421928:layer:Klayers-p38-requests:10
  
  AddToWorkDocsManualReviewFolders:
    Type: AWS::Serverless::Function
    Properties:
      Handler: index.handler
      CodeUri: inline
      Runtime: python3.9
      InlineCode: |
        def handler(event, context):
            return {
                'statusCode': 200,
                'body': 'Hello from the zip archive'
            }

  AddToWorkDocs:
    Type: AWS::Serverless::Function
    Properties:
      Handler: index.handler
      CodeUri: inline
      Runtime: python3.8
      InlineCode: |
        def handler(event, context):
            return {
                'statusCode': 200,
                'body': 'Hello from the zip archive'
            }
      Layers:
        - arn:aws:lambda:us-east-1:770693421928:layer:Klayers-p38-requests:10

  GenerateUploadList:
    Type: AWS::Serverless::Function
    Properties:
      Timeout: 60
      Handler: index.handler
      CodeUri: inline
      Runtime: python3.8
      InlineCode: |
        def handler(event, context):
            return {
                'statusCode': 200,
                'body': 'Hello from the zip archive'
            }
  
  SplitPDFbyGroups:
    Type: AWS::Serverless::Function
    Properties:
      Timeout: 60
      PackageType: Image
      Architectures:
        - arm64
    Metadata:
      Dockerfile: Dockerfile
      DockerContext: ./split_pdf_by_groups
      DockerTag: python3.8-v1
        
  ExtractInvoiceFromPagesFunction:
    Type: AWS::Serverless::Function
    Properties:
      Policies: 
        - SQSSendMessagePolicy:
            QueueName: !GetAtt  CSVCompilerQueue.QueueName
        - S3CrudPolicy:
            BucketName: !Ref PDFPagesStorage
        - S3CrudPolicy:
            BucketName: !Ref AttachmentsStorage
      Events:
        Stream:
          Type: DynamoDB
          Properties:
            Stream: !Ref PagesDDBStreams
            BatchSize: 1
            StartingPosition: LATEST
      Timeout: 30
      PackageType: Image
      Architectures:
        - arm64
      Environment:
        Variables:
          SQS_QUEUE_URL: !Ref CSVCompilerQueue
    Metadata:
      Dockerfile: Dockerfile
      DockerContext: ./extract_invoice_from_pages
      DockerTag: python3.8-v1

  CSVCompilerQueue:
    Type: AWS::SQS::Queue

  CSVsStorage:
    Type: 'AWS::S3::Bucket'
  CSVCompilerFunction:
    Type: AWS::Serverless::Function
    Properties:
      Timeout: 30
      Policies:
        - S3CrudPolicy:
            BucketName: !Ref CSVsStorage
        - SQSPollerPolicy:
            QueueName: !GetAtt CSVCompilerQueue.QueueName
        - {
            "Version": "2012-10-17",
            "Statement": [
                {
                            "Sid": "VisualEditor0",
                            "Effect": "Allow",
                            "Action": [
                                "ssm:DescribeParameters",
                                "ssm:GetParametersByPath",
                                "ssm:GetParameters",
                                "ssm:GetParameter"
                            ],
                            "Resource": "*"
                        }
                    ]
            }
      PackageType: Image
      Architectures:
        - arm64
      Events:
        SQSEvent:
          Type: SQS
          Properties:
            Queue: !GetAtt CSVCompilerQueue.Arn
            BatchSize: 100
            MaximumBatchingWindowInSeconds: 20
    Metadata:
      Dockerfile: Dockerfile
      DockerContext: ./csv_compile
      DockerTag: python3.8-v1
